# Code organisation

## Plotting code is code {.smaller}

Plotting is often done using scripts with a eagerness for seeing the results.

However, plotting code is still code and treating it as such can save time
and tears later.


## Easy adaptation

If you have repeated code consider using:

- loops
- functions/subroutines
  - Make axis a parameter of the function

Other advice:

- Keep (post-)processing of data separate to plotting
  e.g. `calclulate_vorticity()` and `plot_vorticity()` routines.
- When designing functions think about breaking them up according to the matplotlib 'anatomy'


## Easy adaptation

The `numpy.ravel()` function can be particularly useful for flattening multi-dimensional
`ax` arrays.

::::{.columns}
:::{.column width=50%}
This is OK (1D):
```python
import matplotlib.pyplot as plt
fig, ax = plt.subplots(6)

for axis in ax:
    axis.plot(...
```
:::
:::{.column width=50%}
:::
::::

::::{.columns}
:::{.column width=50%}
But this will fail (2D):
```python
import matplotlib.pyplot as plt
fig, ax = plt.subplots(2, 3)

for axis in ax:
    axis.plot(...
```
:::
:::{.column width=50%}
:::{.fragment}
Instead use:
```python
import matplotlib.pyplot as plt
fig, ax = plt.subplots(2, 3)

for axis in ax.ravel():
    axis.plot(...
```
:::
:::
::::


## Easy adaptation

The `**kwargs` functionality can be used to grab any keyword arguments and wrap them
into a dictionary to be passed through wrapper functions.


## Reuse in future

Consider breaking commonly used but verbose routines down into further subsections
to create your own 'plotting library'.

This can be particularly useful if you have domain-specific adaptations to the common
matplotlib or cartopy functions.


```python
import my_plotting_lib as myplot

...
...
```
